generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model AdminUser {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Listing {
  id             Int               @id @default(autoincrement())
  title          String
  brand          String?           // Brand name (Nike, Adidas, Jordan, etc.)
  category       String
  status         ListingStatus     @default(DRAFT)
  moq            Int
  
  // Phase 1: New pricing fields
  costPerPair      Decimal?        // What admin paid supplier
  basePricePerPair Decimal?        // Reference wholesale price
  maxOrderQty      Int?            // Maximum pairs per order (null = unlimited)
  
  inventoryMode  InventoryMode     @default(SIZE_RUN)
  pricingMode    PricingMode       @default(FLAT)
  flatPricePerPair Decimal?
  totalPairs     Int?
  instantBuy     Boolean           @default(false)
  sellerNotes   String?
  stockXLink     String?
  productSKU     String?
  stockXPrice    Decimal?
  stockXPriceUpdatedAt DateTime?
  discordLink   String?
  instagramLink String?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  images         ListingImage[]
  sizes          ListingSize[]
  tierPrices     ListingTierPrice[]
  orders         Order[]
  conversations  Conversation[]
}

model Buyer {
  id             Int      @id @default(autoincrement())
  email          String   @unique
  passwordHash   String
  name           String?
  phone          String?
  emailVerifiedAt DateTime?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  orders         Order[]
  conversations  Conversation[]
  notifications  Notification[]
}

model Order {
  id                      Int          @id @default(autoincrement())
  buyerId                 Int
  listingId               Int
  conversationId          Int?
  status                  OrderStatus  @default(PENDING)
  totalPairs              Int
  totalAmount             Decimal
  shippingAddress         Json?
  notes                   String?
  stripeCheckoutSessionId String?
  stripePaymentIntentId   String?
  paidAt                  DateTime?
  createdAt               DateTime     @default(now())
  updatedAt               DateTime     @updatedAt

  buyer           Buyer         @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  listing         Listing       @relation(fields: [listingId], references: [id], onDelete: Cascade)
  conversation    Conversation? @relation(fields: [conversationId], references: [id])
  items           OrderItem[]
  messages        OrderMessage[]
  notifications   Notification[]
}

model OrderItem {
  id          Int     @id @default(autoincrement())
  orderId     Int
  sizeLabel   String?
  quantity    Int
  pricePerPair Decimal

  order       Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model OrderMessage {
  id            Int       @id @default(autoincrement())
  orderId       Int
  senderType    SenderType
  body          String
  invoiceSentAt DateTime?
  createdAt     DateTime  @default(now())

  order         Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PAID
  SHIPPED
  CANCELLED
}

enum SenderType {
  BUYER
  SELLER
}

model ListingImage {
  id        Int     @id @default(autoincrement())
  url       String
  sortOrder Int     @default(0)

  listingId Int
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
}

model ListingSize {
  id        Int     @id @default(autoincrement())
  sizeLabel String
  quantity  Int     @default(0)
  soldOut   Boolean @default(false)

  listingId Int
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
}

model ListingTierPrice {
  id              Int              @id @default(autoincrement())
  minQty          Int
  pricePerPair    Decimal?         // Used for FIXED_PRICE mode
  discountPercent Decimal?         // Used for PERCENTAGE_OFF mode (0-100)
  pricingType     TierPricingType  @default(FIXED_PRICE)

  listingId Int
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
}

enum ListingStatus {
  DRAFT
  ACTIVE
  SOLD_OUT
  ARCHIVED
}

enum InventoryMode {
  SIZE_RUN
  MIXED_BATCH
}

enum PricingMode {
  FLAT
  TIER
}

enum TierPricingType {
  FIXED_PRICE      // Current: manually set price per tier
  PERCENTAGE_OFF   // New: percentage discount off base price
}

model Conversation {
  id              Int      @id @default(autoincrement())
  buyerId         Int
  listingId       Int
  status          ConversationStatus @default(ACTIVE)
  lastMessageAt   DateTime @default(now())
  unreadByBuyer   Int      @default(0)
  unreadByAdmin   Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  buyer           Buyer     @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  listing         Listing   @relation(fields: [listingId], references: [id], onDelete: Cascade)
  messages        ConversationMessage[]
  orders          Order[]
  notifications   Notification[]

  @@unique([buyerId, listingId])
}

model ConversationMessage {
  id              Int      @id @default(autoincrement())
  conversationId  Int
  senderType      SenderType
  messageType     MessageType @default(TEXT)
  body            String
  metadata        Json?
  createdAt       DateTime @default(now())

  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
}

enum ConversationStatus {
  ACTIVE
  ARCHIVED
  CLOSED
}

enum MessageType {
  TEXT
  OFFER
  COUNTER_OFFER
  PAYMENT_LINK
  SYSTEM
}

model Notification {
  id              Int      @id @default(autoincrement())
  buyerId         Int?     // Nullable for admin notifications
  type            NotificationType
  title           String
  message         String
  link            String?
  read            Boolean  @default(false)
  createdAt       DateTime @default(now())
  
  // Relations
  orderId         Int?
  conversationId  Int?
  buyer           Buyer?        @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  order           Order?        @relation(fields: [orderId], references: [id], onDelete: Cascade)
  conversation    Conversation? @relation(fields: [conversationId], references: [id], onDelete: Cascade)
}

enum NotificationType {
  NEW_OFFER
  NEW_MESSAGE_BUYER
  NEW_MESSAGE_ADMIN
  PAYMENT_LINK_SENT
  PAYMENT_SUCCESS
  ORDER_STATUS_CHANGE
}

model EmailLog {
  id          Int      @id @default(autoincrement())
  to          String
  subject     String
  template    String
  sentAt      DateTime @default(now())
  resendId    String?
  status      EmailStatus @default(PENDING)
  error       String?
}

enum EmailStatus {
  PENDING
  SENT
  FAILED
  BOUNCED
}
